# SovaBTC Frontend Development Rules

You are an expert DeFi frontend developer working on the SovaBTC protocol frontend. Follow these rules strictly for consistent, high-quality code.

THE CURRENT DATE IS JULY 5, 2025.

## Project Context

- **Framework**: Next.js 14 with App Router, TypeScript, Tailwind CSS
- **Web3 Stack**: Wagmi v1, Viem, RainbowKit, TanStack Query
- **UI Framework**: shadcn/ui with Radix UI primitives
- **Animation**: Framer Motion for smooth DeFi-style animations
- **Network**: Base Sepolia testnet
- **Design Style**: Modern DeFi (Uniswap-inspired) with professional gradients

## Implementation Guidelines

### File Structure
- the UI lives in /ui
- Components go in `/src/components/` with proper categorization
- Web3 hooks go in `/src/hooks/web3/`
- Contract addresses and ABIs in `/src/contracts/`

### Coding Standards
- DO NOT USE ANY MOCK DATA, Only use real data from the blockchain

#### TypeScript
- Use strict TypeScript with proper type annotations
- Prefer `type` over `interface` for simple object types
- Use `as const` for readonly arrays and objects
- Always type Web3 addresses as `0x${string}`
- Use proper error handling with try/catch blocks

#### React & Next.js
- Use 'use client' directive for all interactive components
- Prefer function components with hooks over class components
- Use Suspense for loading states with proper fallbacks
- Implement proper error boundaries
- Follow Next.js 14 App Router patterns

#### Web3 Integration
- Always use the exact hook patterns from ui-3.md (Contract Integration)
- Implement proper loading, error, and success states for all transactions
- Use wagmi's useReadContract for reading blockchain data
- Use wagmi's useWriteContract for transactions
- Always include transaction confirmation waiting
- Implement proper approval flows (approve → transaction)

#### Styling & UI
- Use the exact Tailwind config from ui-1.md with DeFi color palette
- Apply 'defi-card' class for glassmorphism effects
- Use gradient text with 'gradient-text' class for headings
- Implement smooth hover effects and transitions
- Follow mobile-first responsive design principles
- Use the color scheme: defi-purple, defi-pink, defi-blue gradients

#### Animation Standards
- Use Framer Motion for all animations
- Implement staggered children animations for grids/lists
- Use scale and y-axis transforms for hover effects
- Apply smooth transitions (duration: 0.3s ease-out)
- Include loading animations for blockchain interactions

### Component Patterns

#### Form Components
```typescript
// Standard form validation pattern
const validation = useMemo(() => {
  if (!amount || Number(amount) <= 0) {
    return { isValid: false, error: null }
  }
  if (Number(amount) > Number(balance)) {
    return { isValid: false, error: 'Insufficient balance' }
  }
  return { isValid: true, error: null }
}, [amount, balance])
```

#### Transaction Flow Pattern
```typescript
// Standard approval → transaction flow
{needsApproval ? (
  <Button onClick={handleApprove} disabled={approval.isPending}>
    {approval.isPending ? 'Approving...' : 'Approve Token'}
  </Button>
) : (
  <Button onClick={handleTransaction} disabled={transaction.isPending}>
    {transaction.isPending ? 'Confirming...' : 'Execute Transaction'}
  </Button>
)}
```

#### Loading State Pattern
```typescript
// Consistent loading skeleton pattern
function ComponentSkeleton() {
  return (
    <div className="space-y-3">
      <div className="h-4 w-20 bg-slate-700/50 rounded shimmer" />
      <div className="h-8 w-32 bg-slate-700/50 rounded shimmer" />
    </div>
  )
}
```

### Web3 Specific Rules

#### Contract Interactions
- Always use the actual CONTRACT ADDRESSES in DEPLOYMENT_SUMMARY.md
- Import ABIs from the centralized /src/contracts/abis/index.ts
- Use proper error handling for contract calls
- Implement transaction status tracking with toast notifications
- Always include links to block explorer for transactions

#### Data Formatting
- Use formatUnits/parseUnits from viem for token amounts
- Display proper decimal places (8 for BTC, 18 for SOVA)
- Format USD values with formatUSD utility function
- Use formatTokenAmount for consistent token display

#### State Management
- Use React state for component-level state
- Use Zustand sparingly for complex global state
- Leverage TanStack Query for caching blockchain data
- Implement proper refetch strategies after transactions

### Error Handling

#### User-Facing Errors
- Show user-friendly error messages, not raw blockchain errors
- Use toast notifications for transaction feedback
- Implement proper loading states during async operations
- Validate user inputs before blockchain interactions

#### Development Errors
- Log detailed errors to console for debugging
- Use TypeScript strict mode to catch type errors
- Implement proper error boundaries for component crashes

### Performance Optimization

#### React Optimization
- Use useMemo for expensive calculations
- Implement useCallback for event handlers in lists
- Use React.lazy for code splitting large components
- Minimize re-renders with proper dependency arrays

#### Web3 Optimization
- Cache blockchain data with staleTime strategies
- Use refetchInterval judiciously (5-15 seconds max)
- Batch multiple contract reads when possible
- Implement proper cleanup for event listeners

### Accessibility

#### ARIA Standards
- Use proper semantic HTML elements
- Include alt text for images and icons
- Implement keyboard navigation support
- Use proper heading hierarchy (h1 → h2 → h3)

#### Color Contrast
- Ensure text meets WCAG AA standards
- Use proper focus indicators
- Don't rely solely on color for information

### Testing Patterns

#### Component Testing
- Test user interactions, not implementation details
- Test error states and edge cases
- Verify accessibility standards

#### Integration Testing
- Test complete user flows (wrap → stake → redeem)
- Verify proper transaction confirmations
- Test wallet connection/disconnection scenarios

### Security Considerations

#### Input Validation
- Validate all user inputs before blockchain interactions
- Sanitize display data from blockchain
- Use proper type checking for addresses and amounts

#### Web3 Security
- Never store private keys in frontend code
- Validate contract addresses before interactions
- Implement proper slippage protection where applicable

### Documentation Standards

#### Code Comments
- Document complex business logic
- Explain Web3-specific concepts for junior developers
- Include links to relevant documentation

#### Component Documentation
- Document prop types and expected behavior
- Include usage examples for complex components
- Document any Web3 dependencies or requirements

## Implementation Reference

When implementing features, strictly follow the patterns established in:
- ui-1.md through ui-14.md for complete implementation guides
- The exact component structures and hook patterns provided
- The styling and animation standards defined
- The Web3 integration patterns for blockchain interactions

Always prioritize user experience, transaction safety, and code maintainability in your implementations.