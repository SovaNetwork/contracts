# SovaBTC Pooled-Wrapper Implementation Script for Cursor

## Project Overview
Transform SovaBTC wrapper into a robust, multi-chain Bitcoin-backed token protocol with LayerZero OFT integration, redemption queues, and custodial controls.

## Prerequisites Setup
```bash
# Install dependencies first
forge install OpenZeppelin/openzeppelin-contracts
forge install LayerZero-Labs/LayerZero-v2
npm install @layerzerolabs/oft-evm
```

## Task Execution Order

### TASK 1: Whitelist Management System
**Objective**: Implement admin-controlled whitelist for approved BTC-pegged tokens

**Files to Create/Modify**:
- `contracts/TokenWhitelist.sol` (new)
- `contracts/SovaBTCWrapper.sol` (modify existing or create)

**Acceptance Criteria**:
- ✅ `mapping(address => bool) public allowedTokens`
- ✅ `mapping(address => uint8) public tokenDecimals` 
- ✅ `addAllowedToken(address token)` function (onlyOwner)
- ✅ `removeAllowedToken(address token)` function (onlyOwner)
- ✅ `TokenWhitelistUpdated` event emission
- ✅ Whitelist validation in deposit functions

**Implementation Notes**:
- Use OpenZeppelin's `Ownable` for access control
- Store token decimals via `IERC20Metadata(token).decimals()`
- Emit events for transparency
- Handle graceful removal (allow existing redemptions)

**Test Requirements**:
- Admin can add/remove tokens
- Non-admin cannot modify whitelist
- Decimals are correctly stored
- Events are properly emitted

---

### TASK 2: Multi-Token Deposit & Mint System
**Objective**: Enable deposits of approved BTC-pegged tokens with SovaBTC minting

**Files to Create/Modify**:
- `contracts/SovaBTCWrapper.sol` (primary implementation)
- `contracts/interfaces/ISovaBTC.sol` (interface)

**Acceptance Criteria**:
- ✅ `deposit(address token, uint256 amount)` function
- ✅ Token whitelist validation
- ✅ Decimal conversion logic (all tokens → 8 decimal SovaBTC)
- ✅ Minimum deposit enforcement (`minDepositSatoshi`)
- ✅ Safe token transfers from user to contract
- ✅ `adminMint` capability on SovaBTC contract
- ✅ `TokenWrapped` event emission

**Implementation Notes**:
- Use `nonReentrant` and `whenNotPaused` modifiers
- Conversion formula: `sovaAmount = amount * 10^(8 - tokenDecimals[token])`
- Require exact satoshi multiples for tokens with >8 decimals
- Use SafeERC20 for transfers
- Validate `amount > 0` and `sovaAmount >= minDepositSatoshi`

**Test Requirements**:
- Deposits work for 6, 8, 18 decimal tokens
- Conversion math is accurate
- Minimum deposit enforcement
- Failed transfers revert properly
- Events contain correct data

---

### TASK 3: LayerZero OFT Integration
**Objective**: Make SovaBTC omnichain via LayerZero OFT standard

**Files to Create/Modify**:
- `contracts/SovaBTC.sol` (major refactor)
- `contracts/SovaBTCOFT.sol` (new OFT implementation)
- `script/deploy/DeployOFT.s.sol` (deployment script)

**Acceptance Criteria**:
- ✅ Inherit from LayerZero's `OFT` contract
- ✅ Cross-chain burn/mint messaging
- ✅ Endpoint configuration per chain
- ✅ Trusted remote address setup
- ✅ `sendFrom()` function for cross-chain transfers
- ✅ Maintain unified total supply across chains
- ✅ Admin mint restrictions (only wrapper contract)

**Implementation Notes**:
- Constructor takes LayerZero endpoint address
- Configure peer addresses for each supported chain
- Restrict `adminMint` to wrapper contract only
- Test with LayerZero testnet endpoints first
- Consider gas estimation for cross-chain transfers

**Test Requirements**:
- Cross-chain transfers burn on source, mint on destination
- Total supply remains constant across chains
- Only authorized contracts can mint
- Endpoint configuration works correctly

---

### TASK 4: Redemption Queue System
**Objective**: Implement queued redemption with configurable delays

**Files to Create/Modify**:
- `contracts/RedemptionQueue.sol` (new)
- `contracts/SovaBTCWrapper.sol` (integrate queue)

**Acceptance Criteria**:
- ✅ `RedemptionRequest` struct with user, token, amount, timestamp
- ✅ `redeem(address token, uint256 sovaAmount)` queues request
- ✅ Immediate SovaBTC burning on request
- ✅ Configurable `redemptionDelay` (default 10 days)
- ✅ `fulfillRedemption()` function after delay
- ✅ Reserve validation at request time
- ✅ `RedemptionQueued` and `RedemptionCompleted` events

**Implementation Notes**:
- Use `mapping(address => RedemptionRequest)` for one request per user
- Burn SovaBTC immediately: `sovaBTC.adminBurn(user, sovaAmount)`
- Check contract balance: `IERC20(token).balanceOf(address(this)) >= underlyingAmount`
- Time validation: `block.timestamp >= request.requestTime + redemptionDelay`
- Mark fulfilled to prevent double-spending

**Test Requirements**:
- Requests queue properly with correct data
- SovaBTC burned immediately
- Fulfillment only works after delay
- Insufficient reserves handled correctly
- Double fulfillment prevention

---

### TASK 5: Immediate BTC Redemption on Sova
**Objective**: Maintain immediate BTC withdrawal capability on Sova chain

**Files to Create/Modify**:
- `contracts/SovaBTCSova.sol` (Sova-specific implementation)
- Keep existing `withdraw()` function from SovaBTC.sol

**Acceptance Criteria**:
- ✅ Retain `withdraw(uint64 amount, uint64 btcGasLimit, uint64 btcBlockHeight, string dest)`
- ✅ Direct Bitcoin transaction via SovaBitcoin precompile
- ✅ Immediate execution (no queue)
- ✅ Integration with OFT (local burn on Sova chain)
- ✅ `Withdraw` event with txid

**Implementation Notes**:
- Only available on Sova chain deployment
- Use existing SovaBitcoin.UBTC_SIGN_TX_BYTES precompile
- Handle pending withdrawal state
- Ensure OFT total supply decreases correctly
- Maintain `whenNotPaused` protection

**Test Requirements**:
- Bitcoin transaction construction works
- SovaBTC balance decreases correctly
- Events emitted with valid txids
- Only works on Sova chain

---

### TASK 6: Security & Admin Controls
**Objective**: Implement custodial restrictions and admin safeguards

**Files to Create/Modify**:
- `contracts/CustodyManager.sol` (new)
- `contracts/SovaBTCWrapper.sol` (add restrictions)

**Acceptance Criteria**:
- ✅ `mapping(address => address) public custodyAddress` (token → custody destination)
- ✅ `setCustodyAddress(address token, address dest)` (onlyOwner)
- ✅ Restrict token withdrawals to custody addresses only
- ✅ Exception for user redemption fulfillment
- ✅ Emergency pause functionality
- ✅ Admin role for redemption fulfillment

**Implementation Notes**:
- Use OpenZeppelin's `AccessControl` for roles
- Create `CUSTODIAN_ROLE` for redemption fulfillment
- Validate destination in all admin transfers: `require(dest == custodyAddress[token])`
- Allow direct-to-user transfers only in `fulfillRedemption`
- Emergency sweep function to move all tokens to custody

**Test Requirements**:
- Only custody addresses can receive admin transfers
- User redemptions work despite restrictions
- Role-based access control functions
- Emergency procedures work correctly

---

### TASK 7: Staking & Yield (Optional)
**Objective**: Implement SovaBTC and SOVA token staking systems

**Files to Create/Modify**:
- `contracts/staking/SovaBTCStaking.sol` (new)
- `contracts/staking/SOVAStaking.sol` (new)
- `contracts/interfaces/IStaking.sol` (new)

**Acceptance Criteria**:
- ✅ Stake SovaBTC, earn SOVA rewards
- ✅ Stake SOVA, earn protocol revenue share
- ✅ Standard staking mechanics (stake, claim, withdraw)
- ✅ Reward rate configuration
- ✅ Cross-chain support consideration

**Implementation Notes**:
- Fork proven staking contract (MasterChef-style)
- Use reward-per-token accumulated model
- Consider lockup periods for enhanced rewards
- Deploy on each chain where SovaBTC exists
- Admin functions to fund reward pools

**Test Requirements**:
- Accurate reward calculations
- Proper stake/unstake mechanics
- Reward distribution works
- Cross-chain coordination

---

## Implementation Workflow for Cursor

### Phase 1: Foundation (Tasks 1-2)
1. **Start with Task 1**: Set up the whitelist system as it's foundational
2. **Then Task 2**: Build deposit functionality on top of whitelist
3. **Test thoroughly**: Ensure basic wrap/mint works before proceeding

### Phase 2: Cross-Chain (Task 3)
1. **LayerZero Integration**: This is complex, take time to understand OFT standard
2. **Test on testnets**: Use LayerZero testnet endpoints
3. **Verify supply consistency**: Ensure burns/mints balance across chains

### Phase 3: Advanced Features (Tasks 4-6)
1. **Implement queue system**: Start with basic queue, then add admin controls
2. **Sova BTC withdrawal**: Integrate with existing Bitcoin precompile
3. **Security layer**: Add custodial restrictions and emergency controls

### Phase 4: Optional Enhancement (Task 7)
1. **Staking contracts**: Only after core functionality is solid
2. **Yield distribution**: Implement reward mechanisms

## Key Dependencies to Install
```solidity
// In remappings.txt
@openzeppelin/=lib/openzeppelin-contracts/
@layerzerolabs/=lib/LayerZero-v2/
```

## Testing Strategy
- Unit tests for each contract
- Integration tests for cross-contract interactions
- LayerZero message testing (use their test framework)
- Upgrade path testing (if using proxy patterns)
- Security testing (slither, mythril)

## Deployment Order
1. Deploy SovaBTC OFT on each chain
2. Configure LayerZero endpoints and peers
3. Deploy wrapper contracts
4. Set up whitelists and custody addresses
5. Deploy staking contracts (optional)
6. Transfer ownership to final admin addresses

---

## Next Steps
1. Review existing SovaBTC.sol and understand current architecture
2. Start with Task 1 implementation
3. Write comprehensive tests for each task
4. Document any deviations from this plan
5. Consider security audits before mainnet deployment